
{% load static i18n %}

<div class="row">
<div class="col-12">
<!--  -->






</div>
</div>
</div>
</div>




    <script type="importmap">
        {
            "imports": {
                "three": "{% static 'build/three.webgpu.js' %}",
                "three/tsl": "{% static 'build/three.webgpu.js' %}",
                "three/addons/": "{% static 'jsm/' %}"
            }
        }
    </script>

    <script type="module">

        import * as THREE from 'three';
        import { step, normalWorld, output, texture, vec3, vec4, normalize, positionWorld, bumpMap, cameraPosition, color, uniform, mix, uv, max } from 'three/tsl';

        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let camera, scene, renderer, controls, globe, clock, marker;

        init();

        function init() {

            clock = new THREE.Clock();

            camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 0.1, 100 );
            camera.position.set( 4.5, 2, 3 );

            scene = new THREE.Scene();

            // sun

            const sun = new THREE.DirectionalLight( '#ffffff', 2 );
            sun.position.set( 0, 0, 3 );
            scene.add( sun );

            // uniforms

            const atmosphereDayColor = uniform( color( '#4db2ff' ) );
            const atmosphereTwilightColor = uniform( color( '#bc490b' ) );
            const roughnessLow = uniform( 0.25 );
            const roughnessHigh = uniform( 0.35 );

            // textures

            const textureLoader = new THREE.TextureLoader();

            const dayTexture = textureLoader.load( '{% static 'textures/planets/earth_day_4096.jpg' %}' );
            dayTexture.colorSpace = THREE.SRGBColorSpace;
            dayTexture.anisotropy = 8;

            const nightTexture = textureLoader.load( '{% static 'textures/planets/earth_night_4096.jpg' %}' );
            nightTexture.colorSpace = THREE.SRGBColorSpace;
            nightTexture.anisotropy = 8;

            const bumpRoughnessCloudsTexture = textureLoader.load( '{% static 'textures/planets/earth_bump_roughness_clouds_4096.jpg' %}' );
            bumpRoughnessCloudsTexture.anisotropy = 8;

            // fresnel

            const viewDirection = positionWorld.sub( cameraPosition ).normalize();
            const fresnel = viewDirection.dot( normalWorld ).abs().oneMinus().toVar();

            // sun orientation

            const sunOrientation = normalWorld.dot( normalize( sun.position ) ).toVar();

            // atmosphere color

            const atmosphereColor = mix( atmosphereTwilightColor, atmosphereDayColor, sunOrientation.smoothstep( - 0.25, 0.75 ) );

            // globe

            const globeMaterial = new THREE.MeshStandardNodeMaterial();

            const cloudsStrength = texture( bumpRoughnessCloudsTexture, uv() ).b.smoothstep( 0.2, 1 );

            globeMaterial.colorNode = mix( texture( dayTexture ), vec3( 1 ), cloudsStrength.mul( 2 ) );

            const roughness = max(
                texture( bumpRoughnessCloudsTexture ).g,
                step( 0.01, cloudsStrength )
            );
            globeMaterial.roughnessNode = roughness.remap( 0, 1, roughnessLow, roughnessHigh );

            const night = texture( nightTexture );
            const dayStrength = sunOrientation.smoothstep( - 0.25, 0.5 );

            const atmosphereDayStrength = sunOrientation.smoothstep( - 0.5, 1 );
            const atmosphereMix = atmosphereDayStrength.mul( fresnel.pow( 2 ) ).clamp( 0, 1 );

            let finalOutput = mix( night.rgb, output.rgb, dayStrength );
            finalOutput = mix( finalOutput, atmosphereColor, atmosphereMix );

            globeMaterial.outputNode = vec4( finalOutput, output.a );

            const bumpElevation = max(
                texture( bumpRoughnessCloudsTexture ).r,
                cloudsStrength
            );
            globeMaterial.normalNode = bumpMap( bumpElevation );

            const sphereGeometry = new THREE.SphereGeometry( 1, 64, 64 );
            globe = new THREE.Mesh( sphereGeometry, globeMaterial );
            scene.add( globe );

            // atmosphere

            const atmosphereMaterial = new THREE.MeshBasicNodeMaterial( { side: THREE.BackSide, transparent: true } );
            let alpha = fresnel.remap( 0.73, 1, 1, 0 ).pow( 3 );
            alpha = alpha.mul( sunOrientation.smoothstep( - 0.5, 1 ) );
            atmosphereMaterial.outputNode = vec4( atmosphereColor, alpha );

            const atmosphere = new THREE.Mesh( sphereGeometry, atmosphereMaterial );
            atmosphere.scale.setScalar( 1.04 );
            scene.add( atmosphere );

            // renderer

            renderer = new THREE.WebGPURenderer();
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setAnimationLoop( animate );
            document.body.appendChild( renderer.domElement );

            // controls

            controls = new OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true;
            controls.minDistance = 0.1;
            controls.maxDistance = 50;

            window.addEventListener( 'resize', onWindowResize );

            // Add marker for Istanbul
            const markerPosition = latLonToVector3(41.0082, 28.9784, 1.08);
            const markerGeometry = new THREE.SphereGeometry(0.02, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: '#ff0000' });
            marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.copy(markerPosition);
            scene.add(marker);


        }

        function latLonToVector3(latitude, longitude, radius) {
            const phi = (90 - latitude) * (Math.PI / 180);
            const theta = (longitude + 180) * (Math.PI / 180);

            const x = -(radius * Math.sin(phi) * Math.cos(theta));
            const y = radius * Math.cos(phi);
            const z = radius * Math.sin(phi) * Math.sin(theta);

            return new THREE.Vector3(x, y, z);
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize( window.innerWidth, window.innerHeight );

        }

        async function animate() {

            const delta = clock.getDelta();
            globe.rotation.y += delta * 0.025;

            controls.update();

            // Update marker position to follow globe rotation
            const markerPosition = latLonToVector3(41.0082, 28.9784, 1.08);
            marker.position.copy(markerPosition.applyQuaternion(globe.quaternion));

            renderer.render( scene, camera );

        }

    </script>


